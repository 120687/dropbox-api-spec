namespace files
    "This endpoint contains endpoints and data types for basic file
    operations."

import common

alias Id = String(min_length=1)
alias Path = String(pattern="/.*")
alias PathOrId = String(pattern="(/|id:).*")
alias PathR = String(pattern="(/.*)?")               # A path that can be the root path ("").
alias Rev = String(min_length=9, pattern="[0-9a-f]+")

#
# Metadata definitions and route
#

struct Metadata
    "Metadata for a file or folder."

    union
        file FileMetadata
        folder FolderMetadata
        deleted DeletedMetadata  # Used by list_folder* and search

    name String
        "The last component of the path (including extension).
        This never contains a slash."
    path_lower String
        "The lowercased full path in the user's Dropbox.
        This always starts with a slash."

    example default
        file = default

    example folder_metadata
        folder = default

struct FileMetadata extends Metadata
    "Metadata (excluding name or path) for a file."

    id Id?
        "A unique identifier for the file."
    client_modified common.DropboxTimestamp
        "For files, this is the modification time set by the desktop client
        when the file was added to Dropbox. Since this time is not verified
        (the Dropbox server stores whatever the desktop client sends up), this
        should only be used for display purposes (such as sorting) and not,
        for example, to determine if a file has changed or not."
    server_modified common.DropboxTimestamp
        "The last time the file was modified on Dropbox."
    rev Rev
        "A unique identifier for the current revision of a file. This field is
        the same rev as elsewhere in the API and can be used to detect changes
        and avoid conflicts."
    size UInt64
        "The file size in bytes."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXw"
        name = "Prime_Numbers.txt"
        path_lower = "/homework/math/prime_numbers.txt"
        client_modified = "2015-05-12T15:50:38Z"
        server_modified = "2015-05-12T15:50:38Z"
        rev = "a1c10ce0dd78"
        size = 7212

struct FolderMetadata extends Metadata
    "Metadata (excluding name or path) for a folder.

    (There are currently no fields defined here, but we will add
    folder-specific metadata in the future.)"

    id Id?
        "A unique identifier for the folder."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXz"
        path_lower = "/homework/math"
        name = "math"

struct DeletedMetadata extends Metadata
    "Indicates a deleted file or folder in results returned by
    :route:`list_folder/continue` or :route:`search`."
    # TODO: Do we care about whether it's a deleted file or folder?
    # TODO: Add the mtime when it's been deleted?  And the rev???

    example default
        path_lower = "/home/math/pi.txt"
        name = "pi.txt"

union GetMetadataError
    "Error returned by :route:`get_metadata`."

    path LookupError

struct GetMetadataArg
    "Arguments for :route:`get_metadata`."

    path PathOrId
        "The path or ID of a file or folder on Dropbox"

    example default
        path = "/Homework/math"

    example id
        path = "id:a4ayc_80_OEAAAAAAAAAYa"

route get_metadata (GetMetadataArg, Metadata, GetMetadataError)
    "Returns the metadata for a file or folder."

#
# List folder routes
#

struct ListFolderArg
    "Arguments for :route:`list_folder`."

    path PathR
        "The path to the folder you want to see the contents of."
    recursive Boolean = false
        "If true, list folder operation will be applied recursively to all subfolders.
        And the response will contain contents of all subfolders"

    example default
        path = "/Homework/math"
        recursive = false

struct ListFolderResult
    "Information returned by :route:`list_folder`."

    entries List(Metadata)
        "The files and (direct) subfolders in the folder."
    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."
    has_more Boolean
        "If true, then there are more entries available. Pass the
        cursor to :route:`list_folder/continue` to retrieve the rest."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"
        has_more = false

union ListFolderError
    "Error returned by :route:`list_folder` and :route:`list_folder/continue`."

    path LookupError
    other*
        "An unspecified error."

route list_folder (ListFolderArg, ListFolderResult, ListFolderError)
    "Returns the contents of a folder.

    NOTE: We're definitely going to streamline this interface."

struct ListFolderContinueArg
    "Arguments for :route:`list_folder/continue`."

    cursor String
        "The cursor returned by :route:`list_folder` or
        :route:`list_folder/continue`."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

union ListFolderContinueError
    "Error returned by :route:`list_folder/continue`."

    path LookupError
    reset
        "Indicates that the cursor has been invalidated. Call
        :route:`list_folder` to obtain a new cursor."
    other*

route list_folder/continue (ListFolderContinueArg, ListFolderResult, ListFolderContinueError)
    "Once a cursor has been retrieved from :route:`list_folder`, use this to
    paginate through all files and retrieve updates to the folder.

    NOTE: We're definitely going to streamline this interface."

struct ListFolderGetLatestCursorResult
    "Information returned by :route:`list_folder/get_latest_cursor`."

    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

route list_folder/get_latest_cursor (ListFolderArg, ListFolderGetLatestCursorResult, ListFolderError)
    "A way to quickly get a cursor for the folder's state. Unlike :route:`list_folder`,
    :route:`list_folder/get_latest_cursor` doesn't return any entries. This endpoint is for app
    which only needs to know about new files and modifications and doesn't need to know about
    files that already exist in Dropbox."

#
# Download
#

union DownloadError
    "Errors from :route:`download`."

    path LookupError
    other*
        "An unspecified error."

struct DownloadArg
    "Arguments for :route:`download`."

    path Path
        "The path of the file to download."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/Homework/math/Prime_Numbers.txt"

    example with_rev
        path = "/Homework/math/Prime_Numbers.txt"
        rev = "a1c10ce0dd78"

route download (DownloadArg, FileMetadata, DownloadError)
    "Download a file from a user's Dropbox."

    attrs
        host="content"
        style="download"

#
# Upload Routes
#

# Errors

struct UploadWriteFailed
    reason WriteError
        "The reason why the file couldn't be saved."
    upload_session_id String
        "The upload session ID; this may be used to retry the commit."

union UploadError
    "Errors for upload."

    path UploadWriteFailed
        "Unable to save the uploaded contents to a file."
    other*
        "An unspecified error."

struct UploadSessionOffsetError
    "Error structure for recovering the correct upload offset."

    correct_offset UInt64
        "The offset up to which data has been collected."

union UploadSessionLookupError
    "Errors related to upload sessions."

    not_found
        "The upload session id was not found."
    incorrect_offset UploadSessionOffsetError
        "The specified offset was incorrect. See the value for the
        correct offset. (This error may occur when a previous request
        was received and processed successfully but the client did not
        receive the response, e.g. due to a network error.)"
    closed
        "You are attempting to append data to an upload session that
        has alread been closed (i.e. committed)."
    other*
        "An unspecified error."

union UploadSessionFinishError
    "Errors for :route:`upload_session/finish`."

    lookup_failed UploadSessionLookupError
        "The session arguments are incorrect; the value explains the reason."
    path WriteError
        "Unable to save the uploaded contents to a file."
    other*
        "An unspecified error."

# Req/Resp

struct UploadSessionStartResult
    "The result of :route:`upload_session/start`."

    session_id String
        "A unique identifier for the upload session. Pass this to
        :route:`upload_session/append` and
        :route:`upload_session/finish`."

    example default
        session_id = "1234faaf0678bcde"

route upload_session/start (Void, UploadSessionStartResult, Void)
    "Start a new upload session. This is used to upload a single file with
    multiple calls."

    attrs
        host="content"
        style="upload"

struct UploadSessionCursor
    "Arguments for :route:`upload_session/append`. Also used by
    :route:`upload_session/finish`."

    session_id String
        "The upload session ID (returned by :route:`upload_session/start`)."
    offset UInt64
        "The amount of data that has been uploaded so far. We use this to make
        sure upload data isn't lost or duplicated in the event of a network
        error."

    example default
        session_id = "1234faaf0678bcde"
        offset = 0

route upload_session/append (UploadSessionCursor, Void, UploadSessionLookupError)
    "Append more data to an upload session."

    attrs
        host="content"
        style="upload"

union WriteMode
    "Your intent when writing a file to some path. This is used to determine
    what constitutes a conflict and what the autorename strategy is.

    In some situations, the conflict behavior is identical:
    (a) If the target path doesn't contain anything, the file is always written;
    no conflict.
    (b) If the target path contains a folder, it's always a conflict.
    (c) If the target path contains a file with identical contents, nothing gets
    written; no conflict.

    The conflict checking differs in the case where there's a file at the target
    path with contents different from the contents you're trying to write."

    add
        "It's always a conflict. The autorename strategy is to append a number
        to the file name. For example \"document.txt\" might become
        \"document (2).txt\"."
    overwrite
        "It's never a conflict. Overwrite the existing file. The autorename
        strategy is the same as it is for :field:`add`."
    update Rev
        "It's a conflict only if the current \"rev\" doesn't match the given
        \"rev\". The autorename strategy is to append the string
        \"conflicted copy\" to the file name. For example,
        \"document.txt\" might become \"document (conflicted
        copy).txt\" or \"document (Panda's conflicted copy).txt\"."

    example default
        add = null

    example overwriting
        overwrite = null

    example with_revision
        update = "a1c10ce0dd78"

struct CommitInfo
    "Arguments for :route:`upload`. Also part of the arguments to
    :route:`upload_session/finish`."

    path Path
        "Path in the user's Dropbox to save the file."
    mode WriteMode = add
        "Selects what to do if the file already exists."
    autorename Boolean = false
        "If there's a conflict, as determined by :field:`mode`, have the Dropbox
        server try to autorename the file to avoid conflict."
    client_modified common.DropboxTimestamp?
        "The value to store as the :field:`client_modified` timestamp. Dropbox
        automatically records the time at which the file was written to the
        Dropbox servers. It can also record an additional timestamp, provided
        by Dropbox desktop clients, mobile clients, and API apps of when the
        file was actually created or modified."
    mute Boolean = false
        "Normally, users are made aware of any file modifications in their
        Dropbox account via notifications in the client software. If
        :val:`true`, this tells the clients that this modification shouldn't
        result in a user notification."

    example default
        path = "/Homework/math/Matrices.txt"
        autorename = true

struct UploadSessionFinishArg
    "Arguments for :route:`upload_session/finish`."

    cursor UploadSessionCursor
        "Contains the upload session ID and the offset."
    commit CommitInfo
        "Contains the path and other optional modifiers for the commit."

    example default
        cursor = default
        commit = default

route upload_session/finish (UploadSessionFinishArg, FileMetadata, UploadSessionFinishError)
    "Finish an upload session and save the uploaded data to the given file
    path."

    attrs
        host="content"
        style="upload"

route upload (CommitInfo, FileMetadata, UploadError)
    "Create a new file with the contents provided in the request."

    attrs
        host="content"
        style="upload"

#
# Search
#

union SearchMode
    "Select which type of data to search."

    filename
        "Search file and folder names."
    filename_and_content
        "Search file and folder names as well as file contents."
    deleted_filename
        "Search for deleted file and folder names."

    example default
        filename_and_content = null

    example name_only
        filename = null

    example deleted_names
        deleted_filename = null

struct SearchQuery
    "Arguments for :route:`search`."

    path PathR
        "The path in the user's Dropbox to search. Should probably be
        a folder."
    query String
        "The string to search for. The search string is split on spaces into
        multiple tokens. For file name searching, the last token is used for
        prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman
        car\")."
    start UInt64 = 0
        "The starting index within the search results (used for paging)."
    max_results UInt64(min_value=1, max_value=1000) = 100
        "The maximum number of search results to return."
    mode SearchMode = filename
        "The search mode (filename, filename_and_content, or deleted_filename)."

    example default
        path = ""
        query = "prime numbers"

union SearchMatchType
    "Indicates what type of match was found for a given item."

    filename
        "This item was matched on its file or folder name."
    content
        "This item was matched based on its file contents."
    both
        "This item was matched based on both its contents and its file name."

    example default
        content = null

struct SearchMatch
    "Describes a search result."

    match_type SearchMatchType
        "The type of the match."
    metadata Metadata
        "The metadata for the matched file or folder."

    example default
        match_type = default
        metadata = default

struct SearchResults
    "Information returned by :route:`search`."

    matches List(SearchMatch)
        "A list (possibly empty) of matches for the query."
    more Boolean
        "Used for paging. If true, indicates there is another page of results
        available that can be fetched by calling :route:`search` again."
    start UInt64
        "Used for paging. Value to set the start argument to when calling
        :route:`search` to fetch the next page of results."

    example default
        more = false
        start = 1

union SearchError
    "Errors for :route:`search`."

    path LookupError
    other*
        "An unspecified error."

route search (SearchQuery, SearchResults, SearchError)
    "Searches for files and folders."

#
# Errors shared by various operations
#

alias MalformedPathError = String?  # TODO: Maybe a user_message-like thing?

union LookupError
    malformed_path MalformedPathError
    not_found
        "There is nothing at the given path."
    not_file
        "We were expecting a file, but the given path refers to something that isn't a file."
    not_folder
        "We were expecting a folder, but the given path refers to something that isn't a folder."
    restricted_content
        "The file cannot be transferred because the content is restricted.  For example,
        sometimes there are legal restrictions due to copyright claims."
    other*

union WriteError
    malformed_path MalformedPathError
    conflict WriteConflictError
        "Couldn't write to the target path because there was something in the way."
    no_write_permission
        "The user doesn't have permissions to write to the target location."
    insufficient_space
        "The user doesn't have enough available space (bytes) to write more data."
    disallowed_name
        "Dropbox will not save the file or folder because it of its name."
    other*

union WriteConflictError
    file
        "There's a file in the way."
    folder
        "There's a folder in the way."
    file_ancestor
        "There's a file at an ancestor path, so we couldn't create the required parent folders."
    other*

#
# Create folder
#

struct CreateFolderArg
    "Arguments for :route:`create_folder`."

    path Path
        "Path in the user's Dropbox to create."

    example default
        path = "/Homework/geometry"

union CreateFolderError
    path WriteError

route create_folder (CreateFolderArg, FolderMetadata, CreateFolderError)
    "Create a folder at a given path.

    No file or folder may exist at the path.
    The parent folder will be created if it does not already exist (and so on).
    If the parent exists it must be a folder (and the same for any ancestor).
    If an ancestor is a shared folder it must have write access."

#
# Delete
#

struct DeleteArg
    "Arguments for :route:`delete`."

    path Path
        "Path in the user's Dropbox to delete."

    example delete
        path = "/Homework/math/Prime_Numbers.txt"

union DeleteError
    path_lookup LookupError
    path_write WriteError
    other*

route delete (DeleteArg, Metadata, DeleteError)
    "Delete the file or folder at a given path.

    If the path is a folder all its contents will be deleted too."

#
# Args and error shared by copy and move
#

struct RelocationArg
    "Arguments for :route:`copy` and :route:`move`."

    from_path Path
        "Path in the user's Dropbox to be copied or moved."
    to_path Path
        "Path in the user's Dropbox that is the destination."

    example default
        from_path = "/Homework/math"
        to_path = "/Homework/algebra"


union RelocationError
    "Errors reported by :route:`copy` and :route:`move`."

    from_lookup LookupError
    from_write WriteError
    to WriteError

    cant_copy_shared_folder
        "Shared folders can't be copied."
    cant_nest_shared_folder
        "Your move operation would result in nested shared folders.  This is not allowed."
    too_many_files
        "The operation would involve more than 10,000 files and folders."
    other*
        "An unspecified error."

#
# Copy
#

route copy (RelocationArg, Metadata, RelocationError)
    "Copy a file or folder to a different destination in the user's Dropbox.

    If the source path is a folder all its contents will be copied.
    The destination path must not yet exist."

#
# Move
#

route move (RelocationArg, Metadata, RelocationError)
    "Move a file or folder to a different destination in the user's Dropbox.

    If the source path is a folder all its contents will be moved.
    The destination path must not yet exist."

#
# Thumbnail
#

union ThumbnailSize
    "The size option for thumbnail image."

    xs
        "32 by 32 px."
    s
        "64 by 64 px."
    m
        "128 by 128 px."
    l
        "640 by 480 px."
    xl
        "1024 by 768"

union ThumbnailFormat
    "The format option for thumbnail image."

    jpeg
    png

struct ThumbnailArg
    "Arguments for :route:`get_thumbnail`.

    This method currently supports files with the following file extensions:
    jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB
    in size won't be converted to a thumbnail."

    path Path
        "The path to the image file you want to thumbnail."
    format ThumbnailFormat = jpeg
        "The format for the thumbnail image, jpeg (default) or png. For
         images that are photos, jpeg should be preferred, while png is
         better for screenshots and digital arts."
    size ThumbnailSize = s
        "The size for the thumbnail image (default s)."

    example default
        path = "/image.jpg"
        format = jpeg
        size = s

union ThumbnailError
    "Errors reported by :route:`get_thumbnail`."

    path LookupError
        "An error occurs when downloading metadata for the image."
    unsupported_extension
        "The file extension doesn't allow conversion to a thumbnail."
    unsupported_format
        "The thumbnail format specified is not supported."
    unsupported_size
        "The size value specified is not supported."
    unsupported_image
        "The image cannot be converted to a thumbnail."
    conversion_error
        "An error occurs during thumbnail conversion."

route get_thumbnail(ThumbnailArg, FileMetadata, ThumbnailError)
    "Get a thumbnail for an image."

    attrs
        host="content"
        style="download"

#
# Preview
#

struct PreviewArg
    "Arguments for :route:`get_preview`."

    path Path
        "The path of the file to preview."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/word.docx"

    example with_rev
        path = "/word.docx"
        rev = "a1c10ce0dd78"

union PreviewError
    "Errors reported by :route:`get_preview`."

    path LookupError
        "An error occurs when downloading metadata for the file."
    in_progress
        "This preview generation is still in progress and the file is not ready
         for preview yet."
    unsupported_extension
        "The file extension is not supported preview generation."
    unsupported_content
        "The file content is not supported for preview generation."

route get_preview(PreviewArg, FileMetadata, PreviewError)
    "Get a preview for a file. Currently previews are only generated for the files with
     the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm, .pptx, .pptm,
     .xls, .xlsx, .xlsm, .rtf"

    attrs
        host="content"
        style="download"

#
# List revisions
#

struct ListRevisionsArg
    "Arguments for :route:`list_revisions`."

    path Path
        "The path to the file you want to see the revisions of."

    limit UInt64(min_value=1, max_value=100) = 10
        "The maximum number of revision entries returned."

    # TODO: Add last_rev when we get pagination support from FJ Service.

    example default
        path = "/root/word.docx"
        limit = 10

union ListRevisionsError
    "Errors reported by :route:`list_revisions`."

    path LookupError

struct ListRevisionsResult
    "Information returned by :route:`list_revisions`."

    is_deleted Boolean
        "If the file is deleted."
    entries List(FileMetadata)
        "The revisions for the file. Only non-delete revisions will show up here."

route list_revisions(ListRevisionsArg, ListRevisionsResult, ListRevisionsError)
    "Return revisions of a file"

#
# Restore
#

struct RestoreArg
    "Arguments for :route:`restore`."

    path Path
        "The path to the file you want to restore."

    rev Rev
        "The revision to restore for the file."

    example default
        path = "/root/word.docx"
        rev = "a1c10ce0dd78"

union RestoreError
    "Errors reported by :route:`restore`."

    path_lookup LookupError
        "An error occurs when downloading metadata for the file."
    path_write WriteError
        "An error occurs when trying to restore the file to that path."

    invalid_revision
        "The revision is invalid. It may point to a different file."

route restore(RestoreArg, FileMetadata, RestoreError)
    "Restore a file to a specific revision"
