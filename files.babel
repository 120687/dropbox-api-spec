namespace files
    "This endpoint contains endpoints and data types for basic file
    operations."

import common

alias Id = String(min_length=1)
alias Path = String
alias PathOrId = String
alias Rev = String(min_length=9, pattern="[0-9a-f]+")

#
# Metadata definitions and route
#

struct Metadata
    "Metadata for a file or folder."

    union
        file FileMetadata
        folder FolderMetadata
        deleted DeletedMetadata  # Used by list_folder* and search

    name String
        "The last component of the path (including extension).
        This never contains a slash."
    path_lower String
        "The lowercased full path in the user's Dropbox.
        This always starts with a slash."

    example default
        file = default

    example folder_metadata
        folder = default

struct FileMetadata extends Metadata
    "Metadata (excluding name or path) for a file."

    id Id?
        "A unique identifier for the file."
    client_modified common.DropboxTimestamp
        "For files, this is the modification time set by the desktop client
        when the file was added to Dropbox. Since this time is not verified
        (the Dropbox server stores whatever the desktop client sends up), this
        should only be used for display purposes (such as sorting) and not,
        for example, to determine if a file has changed or not."
    server_modified common.DropboxTimestamp
        "The last time the file was modified on Dropbox."
    rev Rev
        "A unique identifier for the current revision of a file. This field is
        the same rev as elsewhere in the API and can be used to detect changes
        and avoid conflicts."
    size UInt64
        "The file size in bytes."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXw"
        name = "Prime_Numbers.txt"
        path_lower = "/homework/math/prime_numbers.txt"
        client_modified = "2015-05-12T15:50:38Z"
        server_modified = "2015-05-12T15:50:38Z"
        rev = "a1c10ce0dd78"
        size = 7212

struct FolderMetadata extends Metadata
    "Metadata (excluding name or path) for a folder.

    (There are currently no fields defined here, but we will add
    folder-specific metadata in the future.)"

    id Id?
        "A unique identifier for the folder."

    example default
        id = "id:a4ayc_80_OEAAAAAAAAAXz"
        path_lower = "/homework/math"
        name = "math"

struct DeletedMetadata extends Metadata
    "Indicates a deleted file or folder in results returned by
    :route:`list_folder/continue` or :route:`search`."
    # TODO: Do we care about whether it's a deleted file or folder?
    # TODO: Add the mtime when it's been deleted?  And the rev???

    example default
        path_lower = "/home/math/pi.txt"
        name = "pi.txt"

union GetMetadataError
    "Error returned by :route:`get_metadata`."

    not_found
        "File is not found at the specified path."
    other*
        "An unspecified error."

struct GetMetadataArg
    "Arguments for :route:`get_metadata`."

    path PathOrId
        "The path or ID of a file or folder on Dropbox. Must not be the root."

    example default
        path = "/Homework/math"

    example id
        path = "id:a4ayc_80_OEAAAAAAAAAYa"

route get_metadata (GetMetadataArg, Metadata, GetMetadataError)
    "Returns the metadata for a file or folder."

#
# List folder routes
#

struct ListFolderArg
    "Arguments for :route:`list_folder`."

    path Path
        "The path to the folder you want to see the contents of.
        May be the root (i.e. empty)."
    recursive Boolean = false
        "If true, list folder operation will be applied recursively to all subfolders.
        And the response will contain contents of all subfolders"
    example default
        path = "/Homework/math"
        recursive = false

struct ListFolderResult
    "Information returned by :route:`list_folder`."

    entries List(Metadata)
        "The files and (direct) subfolders in the folder."
    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."
    has_more Boolean
        "If true, then there are more entries available. Pass the
        cursor to :route:`list_folder/continue` to retrieve the rest."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"
        has_more = false

union FolderPathError
    "Base class for errors returned by :route:`list_folder`."

    not_found
        "There is no file or folder at the given path."
    not_folder
        "Entry at path is not a folder."

union ListFolderError extends FolderPathError
    "Error returned by :route:`list_folder` and :route:`list_folder/continue`."

    other*
        "An unspecified error."

route list_folder (ListFolderArg, ListFolderResult, ListFolderError)
    "Returns the contents of a folder.

    NOTE: We're definitely going to streamline this interface."

struct ListFolderContinueArg
    "Arguments for :route:`list_folder/continue`."

    cursor String
        "The cursor returned by :route:`list_folder` or
        :route:`list_folder/continue`."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

union ListFolderContinueError extends ListFolderError
    "Error returned by :route:`list_folder/continue`."

    reset
        "Indicates that the cursor has been invalidated. Call
        :route:`list_folder` to obtain a new cursor."

route list_folder/continue (ListFolderContinueArg, ListFolderResult, ListFolderContinueError)
    "Once a cursor has been retrieved from :route:`list_folder`, use this to
    paginate through all files and retrieve updates to the folder.

    NOTE: We're definitely going to streamline this interface."

struct ListFolderGetLatestCursorResult
    "Information returned by :route:`list_folder/get_latest_cursor`."

    cursor String
        "Pass the cursor into :route:`list_folder/continue` to see what's
        changed in the folder since your previous query."

    example default
        cursor = "ZtkX9_EHj3x7PMkVuFIhwKYXEpwpLwyxp9vMKomUhllil9q7eWiAu"

route list_folder/get_latest_cursor (ListFolderArg, ListFolderGetLatestCursorResult, ListFolderError)
    "A way to quickly get a cursor for the folder's state. Unlike :route:`list_folder`,
    :route:`list_folder/get_latest_cursor` doesn't return any entries. This endpoint is for app
    which only needs to know about new files and modifications and doesn't need to know about
    files that already exist in Dropbox."

#
# Download
#

union NoFileReason
    "Errors from :route:`download` when the file cannot be downloaded."

    not_found
        "The path is not found."
    is_folder
        "The path refers to a folder. Only files can be downloaded."

struct NoFile
    "Error structure for :route:`download`."

    reason NoFileReason
        "The path could not be downloaded. The value gives the reason."

union RestrictedReason
    "Errors for :route:`download` when download is forbidden."

    dmca
        "The download is forbidden because of a DMCA (U.S. Digital
        Millenium Copyright Act) takedown request."
    other*
        "The download is forbidden for some other reason."

struct Restricted
    "Error structure for :route:`download`."

    reason RestrictedReason
        "The download is forbidden. The value gives the reason."

union DisallowedReason
    "Errors for :route:`download` when download is disallowed or forbidden."

    permission
        "The requesting user has no permission to access the file."
    restricted Restricted
        "The download is forbidden; see the value for the reason."

struct Disallowed
    "Error structure for :route:`download`."

    reason DisallowedReason
        "The reason why the download is disallowed."

union DownloadError
    "Errors from :route:`download`."

    disallowed Disallowed
        "The download is disallowed or forbidden; see the value for the reason."
    no_file NoFile
        "The path cannot be downloaded."
    other*
        "An unspecified error."

struct DownloadArg
    "Arguments for :route:`download`."

    path Path
        "The path of the file to download."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/Homework/math/Prime_Numbers.txt"

    example with_rev
        path = "/Homework/math/Prime_Numbers.txt"
        rev = "a1c10ce0dd78"

route download (DownloadArg, FileMetadata, DownloadError)
    "Download a file from a user's Dropbox."

    attrs
        host="content"
        style="download"

#
# Upload Routes
#

# Errors

union CommitConflictError
    "Errors related to commit conflicts."

    file
        "A file already exists at this path."
    folder
        "A folder already exists at this path."
    autorename_failed
        "File could not be automatically renamed."
    other*
        "An unspecified error."

union CommitError
    "Errors from :route:`upload`."

    conflict CommitConflictError
        "A conflict prevented the commit. See the value for the reason."
    no_write_permission
        "User does not have permission to write in the folder. An example of
        this is if the folder is a read-only shared folder."
    insufficient_quota
        "User does not have sufficient space quota to save the file."
    other*
        "An unspecified error."

struct UploadCommitError
    "Error structure for commit errors."

    reason CommitError
        "The reason why the commit failed."
    upload_session_id String
        "The upload session ID; this may be used to retry the commit."

struct UploadSessionOffsetError
    "Error structure for recovering the correct upload offset."

    correct_offset UInt64
        "The offset up to which data has been collected."

union UploadSessionLookupError
    "Errors related to upload sessions."

    not_found
        "The upload session id was not found."
    incorrect_offset UploadSessionOffsetError
        "The specified offset was incorrect. See the value for the
        correct offset. (This error may occur when a previous request
        was received and processed successfully but the client did not
        receive the response, e.g. due to a network error.)"
    closed
        "You are attempting to append data to an upload session that
        has alread been closed (i.e. committed)."
    other*
        "An unspecified error."

union UploadError
    "Errors for upload."

    commit_failed UploadCommitError
        "The upload failed; the value explains the reason."
    other*
        "An unspecified error."

union UploadSessionFinishError
    "Errors for :route:`upload_session/finish`."

    lookup_failed UploadSessionLookupError
        "The session arguments are incorrect; the value explains the reason."
    commit_failed CommitError
        "The commit failed; the value explains the reason."
    other*
        "An unspecified error."

# Req/Resp

struct UploadSessionStartResult
    "The result of :route:`upload_session/start`."

    session_id String
        "A unique identifier for the upload session. Pass this to
        :route:`upload_session/append` and
        :route:`upload_session/finish`."

    example default
        session_id = "1234faaf0678bcde"

route upload_session/start (Void, UploadSessionStartResult, Void)
    "Start a new upload session. This is used to upload a single file with
    multiple calls."

    attrs
        host="content"
        style="upload"

struct UploadSessionCursor
    "Arguments for :route:`upload_session/append`. Also used by
    :route:`upload_session/finish`."

    session_id String
        "The upload session ID (returned by :route:`upload_session/start`)."
    offset UInt64
        "The amount of data that has been uploaded so far. We use this to make
        sure upload data isn't lost or duplicated in the event of a network
        error."

    example default
        session_id = "1234faaf0678bcde"
        offset = 0

route upload_session/append (UploadSessionCursor, Void, UploadSessionLookupError)
    "Append more data to an upload session."

    attrs
        host="content"
        style="upload"

union WriteMode
    "Your intent when writing a file to some path. This is used to determine
    what constitutes a conflict and what the autorename strategy is.

    In some situations, the conflict behavior is identical:
    (a) If the target path doesn't contain anything, the file is always written;
    no conflict.
    (b) If the target path contains a folder, it's always a conflict.
    (c) If the target path contains a file with identical contents, nothing gets
    written; no conflict.

    The conflict checking differs in the case where there's a file at the target
    path with contents different from the contents you're trying to write."

    add
        "It's always a conflict. The autorename strategy is to append a number
        to the file name. For example \"document.txt\" might become
        \"document (2).txt\"."
    overwrite
        "It's never a conflict. Overwrite the existing file. The autorename
        strategy is the same as it is for :field:`add`."
    update Rev
        "It's a conflict only if the current \"rev\" doesn't match the given
        \"rev\". The autorename strategy is to append the string
        \"conflicted copy\" to the file name. For example,
        \"document.txt\" might become \"document (conflicted
        copy).txt\" or \"document (Panda's conflicted copy).txt\"."

    example default
        add = null

    example overwriting
        overwrite = null

    example with_revision
        update = "a1c10ce0dd78"

struct CommitInfo
    "Arguments for :route:`upload`. Also part of the arguments to
    :route:`upload_session/finish`."

    path Path
        "Path in the user's Dropbox to save the file."
    mode WriteMode = add
        "Selects what to do if the file already exists."
    autorename Boolean = false
        "If there's a conflict, as determined by :field:`mode`, have the Dropbox
        server try to autorename the file to avoid conflict."
    client_modified common.DropboxTimestamp?
        "The value to store as the :field:`client_modified` timestamp. Dropbox
        automatically records the time at which the file was written to the
        Dropbox servers. It can also record an additional timestamp, provided
        by Dropbox desktop clients, mobile clients, and API apps of when the
        file was actually created or modified."
    mute Boolean = false
        "Normally, users are made aware of any file modifications in their
        Dropbox account via notifications in the client software. If
        :val:`true`, this tells the clients that this modification shouldn't
        result in a user notification."

    example default
        path = "/Homework/math/Matrices.txt"
        autorename = true

struct UploadSessionFinishArg
    "Arguments for :route:`upload_session/finish`."

    cursor UploadSessionCursor
        "Contains the upload session ID and the offset."
    commit CommitInfo
        "Contains the path and other optional modifiers for the commit."

    example default
        cursor = default
        commit = default

route upload_session/finish (UploadSessionFinishArg, FileMetadata, UploadSessionFinishError)
    "Finish an upload session and save the uploaded data to the given file
    path."

    attrs
        host="content"
        style="upload"

route upload (CommitInfo, FileMetadata, UploadError)
    "Create a new file with the contents provided in the request."

    attrs
        host="content"
        style="upload"

#
# Search
#

union SearchMode
    "Select which type of data to search."

    filename
        "Search file and folder names."
    filename_and_content
        "Search file and folder names as well as file contents."
    deleted_filename
        "Search for deleted file and folder names."

    example default
        filename_and_content = null

    example name_only
        filename = null

    example deleted_names
        deleted_filename = null

struct SearchQuery
    "Arguments for :route:`search`."

    path Path
        "The path in the user's Dropbox to search. Should probably be
        a folder. May be the root (i.e. empty)."
    query String
        "The string to search for. The search string is split on spaces into
        multiple tokens. For file name searching, the last token is used for
        prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman
        car\")."
    start UInt64 = 0
        "The starting index within the search results (used for paging)."
    max_results UInt64(min_value=1, max_value=1000) = 100
        "The maximum number of search results to return."
    mode SearchMode = filename
        "The search mode (filename, filename_and_content, or deleted_filename)."

    example default
        path = ""
        query = "prime numbers"

union SearchMatchType
    "Indicates what type of match was found for a given item."

    filename
        "This item was matched on its file or folder name."
    content
        "This item was matched based on its file contents."
    both
        "This item was matched based on both its contents and its file name."

    example default
        content = null

struct SearchMatch
    "Describes a search result."

    match_type SearchMatchType
        "The type of the match."
    metadata Metadata
        "The metadata for the matched file or folder."

    example default
        match_type = default
        metadata = default

struct SearchResults
    "Information returned by :route:`search`."

    matches List(SearchMatch)
        "A list (possibly empty) of matches for the query."
    more Boolean
        "Used for paging. If true, indicates there is another page of results
        available that can be fetched by calling :route:`search` again."
    start UInt64
        "Used for paging. Value to set the start argument to when calling
        :route:`search` to fetch the next page of results."

    example default
        more = false
        start = 1

union SearchError extends FolderPathError
    "Errors for :route:`search`."

    other*
        "An unspecified error."

route search (SearchQuery, SearchResults, SearchError)
    "Searches for files and folders."

#
# Errors shared by various operations
#

union PathError
    "Path validation errors."

    # State-free errors
    root_disallowed
        "The path should not be empty."
    malformed_path String
        "The path is invalid; the message gives more info."
    # Read errors
    not_found
        "The path does not exist."
    file_disallowed
        "The path should refer to a folder."
    folder_disallowed
        "The path should refer to a file."
    # TODO: dmca, restricted, permission?
    # Write errors
    conflict_file
        "A file already exists there."
    conflict_folder
        "A folder already exists there."
    conflict_file_ancestor
        "An ancestor is a file."
    read_only
        "No write permission."
    shared_folder_disallowed
        "The path should not refer to a shared folder."
    autorename_filed
        "Automatic rename would result in a malformed path (e.g. too long)."
    misc String
        "Miscellaneous error (see error message)."
    other*
        "An unspecified error."

#
# Create folder
#

struct CreateFolderArg
    "Arguments for :route:`create_folder`."

    path Path
        "Path in the user's Dropbox to create."

    example default
        path = "/Homework/geometry"

route create_folder (CreateFolderArg, FolderMetadata, PathError)
    "Create a folder at a given path.

    No file or folder may exist at the path.
    The parent folder will be created if it does not already exist (and so on).
    If the parent exists it must be a folder (and the same for any ancestor).
    If an ancestor is a shared folder it must have write access."

#
# Delete
#

struct DeleteArg
    "Arguments for :route:`delete`."

    path Path
        "Path in the user's Dropbox to delete."

    example delete
        path = "/Homework/math/Prime_Numbers.txt"

route delete (DeleteArg, Metadata, PathError)
    "Delete the file or folder at a given path.

    If the path is a folder all its contents will be deleted too."

#
# Args and error shared by copy and move
#

struct RelocationArg
    "Arguments for :route:`copy` and :route:`move`."

    from_path Path
        "Path in the user's Dropbox to be copied or moved."
    to_path Path
        "Path in the user's Dropbox that is the destination."

    example default
        from_path = "/Homework/math"
        to_path = "/Homework/algebra"


union RelocationError
    "Errors reported by :route:`copy` and :route:`move`.

    This is not just an extension of PathError; there are alternatives
    for errors relating to the source, the destination, and the copy
    operation itself."
    from_error PathError
        "The operation is disallowed due to a problem with the source path."
    to_error PathError
        "The operation is disallowed due to a problem with the destination path."
    too_many_files
        "The operation would involve more than 10,000 files and folders."
    quota_error
        "Quota exceeded."
    other*
        "An unspecified error."

#
# Copy
#

route copy (RelocationArg, Metadata, RelocationError)
    "Copy a file or folder to a different destination in the user's Dropbox.

    If the source path is a folder all its contents will be copied.
    The destination path must not yet exist."

#
# Move
#

route move (RelocationArg, Metadata, RelocationError)
    "Move a file or folder to a different destination in the user's Dropbox.

    If the source path is a folder all its contents will be moved.
    The destination path must not yet exist."

#
# Thumbnail
#

union ThumbnailSize
    "The size option for thumbnail image."

    xs
        "32 by 32 px."
    s
        "64 by 64 px."
    m
        "128 by 128 px."
    l
        "640 by 480 px."
    xl
        "1024 by 768"

union ThumbnailFormat
    "The format option for thumbnail image."

    jpeg
    png

struct ThumbnailArg
    "Arguments for :route:`get_thumbnail`.

    This method currently supports files with the following file extensions:
    jpg, jpeg, png, tiff, tif, gif and bmp. Photos that are larger than 20MB
    in size won't be converted to a thumbnail."

    path Path
        "The path to the image file you want to thumbnail."
    format ThumbnailFormat = jpeg
        "The format for the thumbnail image, jpeg (default) or png. For
         images that are photos, jpeg should be preferred, while png is
         better for screenshots and digital arts."
    size ThumbnailSize = s
        "The size for the thumbnail image (default s)."

    example default
        path = "/image.jpg"
        format = jpeg
        size = s

union ThumbnailError
    "Errors reported by :route:`get_thumbnail`."

    download_error DownloadError
        "An error occurs when downloading metadata for the image."
    unsupported_extension
        "The file extension doesn't allow conversion to a thumbnail."
    unsupported_format
        "The thumbnail format specified is not supported."
    unsupported_size
        "The size value specified is not supported."
    unsupported_image
        "The image cannot be converted to a thumbnail."
    conversion_error
        "An error occurs during thumbnail conversion."

route get_thumbnail(ThumbnailArg, FileMetadata, ThumbnailError)
    "Get a thumbnail for an image."

    attrs
        host="content"
        style="download"

#
# Preview
#

struct PreviewArg
    "Arguments for :route:`get_preview`."

    path Path
        "The path of the file to preview."
    rev Rev?
        "Optional revision, taken from the corresponding :type:`Metadata` field."

    example default
        path = "/word.docx"

    example with_rev
        path = "/word.docx"
        rev = "a1c10ce0dd78"

union PreviewError
    "Errors reported by :route:`get_preview`."

    download_error DownloadError
        "An error occurs when downloading metadata for the file."
    in_progress
        "This preview generation is still in progress and the file is not ready
         for preview yet."
    unsupported_extension
        "The file extension is not supported preview generation."
    unsupported_content
        "The file content is not supported for preview generation."

route get_preview(PreviewArg, FileMetadata, PreviewError)
    "Get a preview for a file. Currently previews are only generated for the files with
     the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm, .pptx, .pptm,
     .xls, .xlsx, .xlsm, .rtf"

    attrs
        host="content"
        style="download"

#
# List revisions
#

struct ListRevisionsArg
    "Arguments for :route:`list_revisions`."

    path Path
        "The path to the file you want to see the revisions of."

    limit UInt64(min_value=1, max_value=100) = 10
        "The maximum number of revision entries returned."

    # TODO: Add last_rev when we get pagination support from FJ Service.

    example default
        path = "/root/word.docx"
        limit = 10

union ListRevisionsError
    "Errors reported by :route:`list_revisions`."

    download_error DownloadError
        "An error occurs when downloading metadata for the file."

struct ListRevisionsResult
    "Information returned by :route:`list_revisions`."

    is_deleted Boolean
        "If the file is deleted."
    entries List(FileMetadata)
        "The revisions for the file. Only non-delete revisions will show up here."

route list_revisions(ListRevisionsArg, ListRevisionsResult, ListRevisionsError)
    "Return revisions of a file"

#
# Restore
#

struct RestoreArg
    "Arguments for :route:`restore`."

    path Path
        "The path to the file you want to restore."

    rev Rev
        "The revision to restore for the file."

    example default
        path = "/root/word.docx"
        rev = "a1c10ce0dd78"

union RestoreError
    "Errors reported by :route:`restore`."

    download_error DownloadError
        "An error occurs when downloading metadata for the file."
    commit_failed CommitError
        "The commit for the restore failed."
    invalid_revision
        "The revision is invalid. It may point to a different file."

route restore(RestoreArg, FileMetadata, RestoreError)
    "Restore a file to a specific revision"
